using sys

using Template in jinja2
using urllib.parse
using * in 原型.简报处理
using 取文件最初提交时间 in 原型.git功用

// 所有基本测试

using 原型.通用测试
using 原型.md相关测试
using 原型.网页相关测试

// 待做：改为选项
重新生成 = false

所有博文 = []
所有简报 = []

// 加任意选项则仅统计
仅统计 = len(sys.argv) == 3

各仓库简报 = 取各仓库简报()

统计数据 = []
所有回复 = []
按题目取简报 = {:}
for 仓库地址 in 仓库表 {
    本仓库内简报 = 各仓库简报[仓库地址]

    最新简报 = max(本仓库内简报, key=简报 -> 简报.时间)

    for 简报 in 本仓库内简报 {
      按题目取简报[简报.题目] = 简报

      if 简报.头部信息.__contains__("回复") {
        回复题目 = 简报.头部信息["回复"]
        被评论 = 按题目取简报[回复题目]
        被评论.评论.append(简报)
        println("`简报.题目` 回复：`被评论.题目`")
      }
    }

    所占空间 = 取所占空间(os.path.join(源数据路径, 仓库表[仓库地址]))
    目标目录 = 仓库表[仓库地址]
    统计数据.append(tuple(目标目录, #本仓库内简报, 所占空间/1000, 最新简报.时间 or "需git信息", 取多种博文题目(最新简报)))
    println("`目标目录` 无博文！") if !本仓库内简报
}

写入csv文件("原型/统计数据.csv", 统计数据)

总占用空间, 总博文数, 总博客数 = 0, 0, 0

for 数据 in 统计数据 {
  总占用空间 += 数据[2]
  总博客数 += 1
  总博文数 += 数据[1]
}

println("`总博客数` 个博客、`总博文数` 篇博文, 占用空间 `总占用空间/1000.0` GB")

sys.exit() if 仅统计

// 以上为统计部分

println("开始生成网页")
for 仓库地址 in 仓库表 {
    目标目录 = 仓库表[仓库地址]
    本仓库内简报 = 各仓库简报[仓库地址]
    for 简报 in 本仓库内简报 {
        简报.仓库源地址 = 仓库地址
        git首尾提交时间 = 取文件最初提交时间(简报.仓库本地路径, 简报.路径)
        简报.时间 = 简报.时间 or git首尾提交时间['首']
        简报.更新时间 = git首尾提交时间['尾']

        所有博文.append(tuple(目标目录, 简报.时间, 简报.题目))

        // 将所有 md 文件转为 html，置于一个目录中
        子目录 = os.path.join("html", 目标目录)
        if !os.path.exists(子目录) {
          os.makedirs(子目录)
        }

        // 待做: 下面为md格式专用, 应清理
        网页文件 = 简报.题目.replace("/", "_") + ".html"
      // 待做：需重命名，避免各种特殊字符无法编译jekyll（需本地构建？）
        if 简报.的格式 == 格式.html {
          网页文件 = 网页文件.replace(':', '')
        }

        简报.网页 = os.path.join(目标目录, 网页文件)

        // 待做：如网页已生成，反馈此信息
        简报.分类 = 取分类(简报)
    }

    所有简报 += 本仓库内简报
}

// 根据更新情况（对比博文目录），仅对有修改或添加的部分作生成
// 待做：比较时间戳
func 获取新添博文(更新) {
  之前 = set()
  博文时间戳 = {:}
  try 博文表=open("原型/博文目录.csv") {
    for 行 in csv.reader(博文表, delimiter=',') {
      之前.add(行[2])
      博文时间戳[行[0]] = {:} if !博文时间戳.__contains__(行[0])
      博文时间戳[行[0]][行[2]] = 行[1]
    }
  }
  未见 = list(filter(博文 -> !之前.__contains__(博文.题目), 更新))

  有修改 = []
  for 博文 in 更新 {
    if 之前.__contains__(博文.题目) {
      上次提交时间 = 博文时间戳[博文.本地相对路径][博文.题目]
      if 博文.更新时间 and 上次提交时间 != 博文.更新时间 {
        println('`博文.路径`: `上次提交时间` => `博文.更新时间`')
        // 待做: 将更新时间保存到本地
        有修改.append(博文)
      }
    }
  }
  return 未见 + 有修改
}

新添博文 = 获取新添博文(所有简报)

写入csv文件("原型/博文目录.csv", 所有博文)

for 简报 in 新添博文 {
  网页路径 = os.path.join("html", 简报.网页)
  生成网页(简报, 网页路径)
}

// 待做：恢复重新生成所有
// if 重新生成 or !os.path.exists(网页路径)

// 待做：带评论的取评论时间戳，类似论坛帖子更新排序
func 按时间排序(简报列表) {
  // 如果年份大于今年，则视为无效时间戳，排在最后
  简报列表.sort(key=x ->
    x.时间 > str(year() + 1) ? "0`x.时间`" : x.时间
  , reverse=true)
}

// 生成一个索引页，今后可作排序、搜索功能
所有链接 = []
按时间排序(所有简报)
for 简报 in 所有简报 {
  主题 = 简报.题目

  if 简报.本地相对路径 == "xieguanglei.github.io" {
    主题 = 取首行题目(简报) or 主题
  }

  评论数 = 简报.评论 ? "（`#简报.评论` 评论）" : ""
  所有链接.append({
    '题目': 简报.时间 + ' ' + 主题 + 评论数,
    // 待做：提到网页相关
    '链接': urllib.parse.quote(简报.网页)
  })
}
try 模板文件=open('原型/索引模板.html') {
  模板 = Template(模板文件.read())
}

try 索引=open('html/index.html', 'w') {
  索引.write(模板.render(
    {
      '所有博文': 所有链接,
      '仓库数': 总博客数,
      '文章数': 总博文数
    }))
}